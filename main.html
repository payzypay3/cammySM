
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Inventory Dashboard with Filters</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=ABeeZee:ital@0;1&family=Ancizar+Sans:ital,wght@0,100..1000;1,100..1000&family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
<style>
:root {
  --bg-light: #f5f7fa;
  --bg-dark: #121212;
  --text-light: #333;
  --text-dark: #eee;
  --primary: #007bff;
  --danger: #dc3545;
  --success: #28a745;
  --warning: #ffc107;
  --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
body {
  margin: 0; padding: 0;
  font-family: var(--font-family);
  background: var(--bg-light);
  color: var(--text-light);
  transition: background-color 0.3s, color 0.3s;
}
body.dark {
  background: var(--bg-dark);
  color: var(--text-dark);
}
h1 {
  text-align: center;
  margin: 1rem 0;
}
.container {
  max-width: 1400px; /* Increased width */
  margin: auto;
  padding: 1rem;
}
/* Filter section */
.filters {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-bottom: 1rem;
  align-items: center;
}
legend{
  font-family: "ABeeZee", sans-serif;
}


footer{
  background-color: rgb(6, 93, 255);
  height: 50px;
  text-align: center;
  color: white;


}
label{
  font-family: "ABeeZee", sans-serif;
}
.filters label {
  font-weight: 600;
}
.filters input[type="text"], .filters select {
  padding: 0.4rem 0.6rem;
  font-size: 1rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  transition: border-color 0.2s;
}
.filters input[type="text"]:focus, .filters select:focus {
  outline: none;
  border-color: var(--primary);
}
/* Table styles */
table {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 1rem;
}
thead {
  background: var(--primary);
  color: white;
}
body.dark thead {
  background: #0056b3;
}
th, td {
  padding: 0.8rem 1rem; /* Increased padding */
  text-align: left;
  border-bottom: 1px solid #ddd;
}
body.dark th, body.dark td {
  border-color: #444;
}

body.dark tr:hover {
  background: #333;
}

/* Styles for low stock () - between 1 and 5 */
#itemTableBody tr.low-stock {
    background-color: #ffc107; /* Light yellow */
    color: #333; /* Darker text for contrast on yellow */
}
body.dark #itemTableBody tr.low-stock {
    background-color: #e0a800; /* Darker yellow for dark mode */
    color: white;
}

/* Styles for critical low stock (red) - 0 or less. This rule must come AFTER .low-stock for proper override */
#itemTableBody tr.critical-low-stock {
    background-color: #ff5b5b; /* Light red */
    color: white;
}
body.dark #itemTableBody tr.critical-low-stock {
    background-color: #dc3545; /* Darker red for dark mode */
    color: white;
}

  input[type="text"]{
  border-radius: 5px;
  height: 30px;
  margin-bottom: 5px;
 }


/* Buttons */
button {
  cursor: pointer;
  border: none;
  padding: 4px 8px;
  margin: 0 2px;
  border-radius: 4px;
  font-size: 0.9rem;
  transition: background-color 0.2s;
}
button.edit {
  background: var(--primary);
  color: white;
}
button.edit-qty { /* New style for edit quantity button */
  background: #009688; /* A teal color */
  color: white;
}
  button.edit-sold { /* New style for edit quantity button */
  background: #ff6600; /* A teal color */
  color: white;
}
button.delete {
  background: var(--danger);
  color: white;
}
button.duplicate {
  background: var(--warning);
  color: #333;
}
button.sold-inc, button.sold-dec {
  background: var(--success);
  color: white;
  font-weight: 700;
}
button.sold-dec {
  background: #28a745cc;
}
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}



input[type="number"]{
  border-radius: 5px;
  height: 30px;
}
/* Dashboard */
.dashboard {
  display: flex;
  flex-wrap: wrap;
  gap: 1.5rem; /* Increased gap */
  margin-bottom: 2rem;
  justify-content: center;
}
.dashboard .card {
  background: white;
  flex: 1 1 200px; /* Increased base size */
  min-width: 200px; /* Ensured minimum width */
  padding: 1.2rem; /* Increased padding */
  border-radius: 8px;
  box-shadow: 0 0 10px #ccc;
  text-align: center;
}
body.dark .dashboard .card {
  background: #222;
  box-shadow: 0 0 10px #000;
}
.dashboard .card h2 {
  margin: 0 0 0.7rem; /* Adjusted margin */
  font-size: 1.4rem; /* Increased font size */
}
.dashboard .card p {
  margin: 0;
  font-weight: 700;
  font-size: 1.6rem; /* Increased font size */
}
/* Charts container */
.charts {
  display: flex;
  flex-wrap: wrap;
  gap: 2rem;
  justify-content: center;
  margin-bottom: 2rem;
}
.chart-card {
  background: white;
  padding: 1rem;
  border-radius: 8px;
  box-shadow: 0 0 10px #ccc;
  width: 320px;
}
body.dark .chart-card {
  background: #222;
  box-shadow: 0 0 10px #000;
}
/* Dark mode toggle button */
#modeToggleBtn {
  position: fixed;
  top: 10px;
  right: 10px;
  background: var(--primary);
  border-radius: 50%;
  width: 40px; height: 40px;
  font-size: 20px;
  color: white;
  border: none;
  cursor: pointer;
  transition: background-color 0.3s;
  z-index: 1000;
}
#modeToggleBtn:hover {
  background: #0056b3;
}
/* New buttons styling */
.action-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-bottom: 20px;
}

.action-buttons button {
  padding: 8px 15px;
  font-size: 1rem;
  border-radius: 5px;
}

#downloadZipBtn {
  background-color: #6c757d; /* Gray */
  color: white;
}

#downloadZipBtn:hover {
  background-color: #5a6268;
}

#importJsonBtn {
  background-color: #17a2b8; /* Cyan */
  color: white;
}

#importJsonBtn:hover {
  background-color: #138496;
}

#printPdfBtn {
  background-color: #dc3545; /* Red for print */
  color: white;
}

#printPdfBtn:hover {
  background-color: #c82333;
}

/* Responsive */
@media (max-width: 768px) {
  .filters {
    flex-direction: column;
    align-items: stretch;
  }
  .dashboard {
    flex-direction: column;
    align-items: stretch;
  }
  .charts {
    flex-direction: column;
    align-items: center;
  }
  .chart-card {
    width: 100%;
    max-width: 400px;
  }
  .action-buttons {
    flex-direction: column;
    align-items: stretch;
  }
  /* Make buttons stack vertically for smaller screens */
  .item-actions button {
    display: block;
    width: 100%;
    margin-bottom: 5px; /* Add some space between stacked buttons */
    margin-left: 0;
    margin-right: 0;
  }
  .item-actions {
    display: flex; /* Override display: flex; to allow stacking */
    flex-direction: column;
    gap: 5px; /* Ensure consistent spacing */
    align-items: stretch;
  }
}

.container h1{
  font-family: "ABeeZee", sans-serif;
 font-weight: bold;
 font-size: 2.5rem;

}

/* PDF specific styles */
@media print {
  /* Ensure page breaks before these sections */
  .dashboard, .charts {
    page-break-before: always;
  }
  /* Adjust margins for PDF */
  body {
    margin: 0.5in !important; /* Adjust as needed */
  }
}

button[type="submit"]{
  background-color: rgb(0, 183, 255);
  color: white;
  border-radius: 5px;
  height: 30px;

}

/* Styles for the Edit Item Modal */
#editItemModal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1001; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
}

#editItemModal > div {
    background-color: var(--bg-light); /* Use theme variable for background */
    margin: 10% auto; /* 10% from the top and centered */
    padding: 20px;
    border: 1px solid #888;
    width: 80%; /* Could be more or less, depending on screen size */
    max-width: 500px; /* Max width for larger screens */
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

body.dark #editItemModal > div {
    background-color: var(--bg-dark); /* Dark mode background */
    color: var(--text-dark); /* Changed to text-dark for consistency */

}


#editItemModal input[type="text"],
#editItemModal input[type="number"] {
    width: calc(100% - 16px); /* Account for padding */
    padding: 8px;
    margin-bottom: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: var(--bg-light); /* Use theme variable for input background */
    color: var(--text-light); /* Use theme variable for input text color */
}

body.dark #editItemModal input[type="text"],
body.dark #editItemModal input[type="number"] {
    background-color: #333; /* Darker input background for dark mode */
    border-color: #555;
    color: var(--text-dark);
}
input[type="date"]{
  margin-left: 20px;
  height: 30px;
  border-radius: 5px;
 border: 1px solid #ccc;


}

.close-button {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close-button:hover,
.close-button:focus {
    color: #000;
    text-decoration: none;
    cursor: pointer;
}

body.dark .close-button {
    color: #eee;
}

body.dark .close-button:hover,
body.dark .close-button:focus {
    color: white;
}





/* Basic Modal Styles */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1000; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
    justify-content: center; /* Center horizontally */
    align-items: center; /* Center vertically */
}

.modal-content {
    background-color: #fefefe;
    margin: auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%; /* Could be responsive */
    max-width: 800px; /* Max width for larger screens */
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
    animation-name: animatetop;
    animation-duration: 0.4s
}

.modal-content.dark {
    background-color: #333;
    color: #eee;
    border-color: #555;
}

/* Close Button */
.close-button {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
}

.close-button:hover,
.close-button:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}

.dark .close-button {
    color: #bbb;
}
.dark .close-button:hover,
.dark .close-button:focus {
    color: white;
}

/* Sales Log Specific Styles */
.sales-log-filters {
    margin-bottom: 20px;
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap; /* Allow wrapping on smaller screens */
}

.sales-log-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}

.sales-log-table th,
.sales-log-table td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
}

.sales-log-table th {
    background-color: #f2f2f2;
}

.dark .sales-log-table th {
    background-color: #555;
}
.dark .sales-log-table,
.dark .sales-log-table th,
.dark .sales-log-table td {
    border-color: #777;
}

/* Animations */
@keyframes animatetop {
    from {top: -300px; opacity: 0}
    to {top: 0; opacity: 1}
}


/* Scroll Buttons */
.scroll-buttons {
    position: fixed;
    bottom: 20px; /* Adjust as needed */
    right: 20px; /* Adjust as needed */
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 1000; /* Ensure buttons are above other content */
}

.scroll-buttons button {
    background-color: var(--primary); /* Uses your defined primary color */
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1rem;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    transition: background-color 0.3s ease;
}

.scroll-buttons button:hover {
    background-color: var(--primary-dark); /* Assuming you have a darker shade for hover */
    /* If you don't have --primary-dark, you can use a fixed color like #0056b3 */
}

/* Dark mode adjustments for scroll buttons */
body.dark-mode .scroll-buttons button {
    background-color: #555; /* Darker background for dark mode */
    color: #eee;
}

body.dark-mode .scroll-buttons button:hover {
    background-color: #777;
}


</style>
</head>
<body>
<button id="modeToggleBtn" aria-label="Toggle Dark Mode">üåô</button>


<div class="scroll-buttons">
    <button id="scrollToTopBtn" title="Scroll to Top">&#9650; Top</button>
    <button id="scrollToBottomBtn" title="Scroll to Bottom">&#9660; Bottom</button>
</div>

    <header>
        <h1>Inventory Management Dashboard</h1>
    </header>

    <div class="container" id="main-content-area">
        <div class="filters" aria-label="Filter inventory items">
            <label for="filterName">Name:</label>
            <input type="text" id="filterName" placeholder="Search by name" />

            <label for="filterBrand">Brand:</label>
            <input type="text" id="filterBrand" placeholder="Search by brand" />

            <label for="filterStatus">Status:</label>
            <select id="filterStatus" aria-label="Filter by stock status">
                <option value="all">Show All</option>
                <option value="inStock">In Stock</option>
                <option value="soldOut">Sold Out</option>
                <option value="lowStock">Low Stock (&lt;= 5)</option>
                <option value="highSold">High Sold</option>
                <option value="lowSold">Low Sold</option>
                <option value="lastEdited">Last Edited (Newest First)</option>
                <option value="lastSold">Last Sold (Newest First)</option>
            </select>

            <div class="date">
                <label for="filterStartDate">Start Date:</label>
                <input type="date" id="filterStartDate" />

                <label for="filterEndDate">End Date:</label>
                <input type="date" id="filterEndDate" />
            </div>
        </div>

        <div class="action-buttons">
            <button id="downloadZipBtn">Download Inventory (ZIP)</button>
            <input type="file" id="importJsonFile" accept=".json" style="display: none;">
            <button id="importJsonBtn">Import Inventory (JSON)</button>
            <button id="viewSalesLogBtn" class="btn">View Sales Log</button>
            <button id="printPdfBtn">Print PDF</button>
           
        </div>

        <form id="addItemForm" aria-label="Add new inventory item">
            <fieldset>
                <legend>Add New Item</legend>
                <label>
                    Item Name: <input type="text" id="itemName" required />
                </label>
                <label>
                    Brand: <input type="text" id="brand" required />
                </label>
                <label>
                    Total Quantity: <input type="number" id="totalQuantity" min="1" required />
                </label>
                <label>
                    Sold: <input type="number" id="sold" min="0" value="0" required />
                </label>
                <button type="submit">Add Item</button>
            </fieldset>
        </form>

        <table aria-label="Inventory items table" id="itemTable" role="grid">
            <thead>
                <tr>
                    <th>Item Name</th>
                    <th>Brand</th>
                    <th>Qty</th>
                    <th>Sold</th>
                    <th>In Stock</th>
                    <th>Last Sold</th>
                    <th>Last Edited</th>
                    <th>Actions Edit</th>
                </tr>
            </thead>
            <tbody id="itemTableBody"></tbody>
        </table>

        <section class="dashboard" aria-label="Inventory summary">
            <div class="card"><h2>Total Items</h2><p id="totalItemsCount">0</p></div>
            <div class="card"><h2>Total Quantity</h2><p id="totalQuantityCount">0</p></div>
            <div class="card"><h2>Total Sold</h2><p id="totalSoldCount">0</p></div>
            <div class="card"><h2>In Stock</h2><p id="totalInStockCount">0</p></div>
            <div class="card"><p>Sold (Last 1 Hr)<br>
                <span id="totalSoldLast24HoursCount">0</span></p></div>
        </section>

        <section class="charts" aria-label="Sales charts">
            <div class="chart-card">
                <h3>Monthly Sold Items</h3>
                <canvas id="monthlySoldBarChart" aria-label="Bar chart showing items sold per month" role="img"></canvas>
            </div>
            <div class="chart-card">
                <h2 class="text-2xl font-semibold mb-4">Top 20 Recently Sold Items</h2>
                <canvas id="soldItemsPieChart"></canvas>
            </div>
        </section>
    </div> <div id="editItemModal" style="display: none; position: fixed; z-index: 1001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
        <div style="background-color: #fefefe; margin: 10% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
            <span class="close-button" style="color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer;">&times;</span>
            <h2 style="text-align: center; margin-top: 0; font-family: 'ABeeZee', sans-serif;">Edit Item Details</h2>
            <form id="editItemForm">
                <input type="hidden" id="editItemId">
                <p>
                    <label for="editItemName" style="display: block; margin-bottom: 5px;">Item Name:</label>
                    <input type="text" id="editItemName" required style="width: calc(100% - 12px); padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px;">
                </p>
                <p>
                    <label for="editBrand" style="display: block; margin-bottom: 5px;">Brand:</label>
                    <input type="text" id="editBrand" required style="width: calc(100% - 12px); padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px;">
                </p>
                <p>
                    <label for="editTotalQuantity" style="display: block; margin-bottom: 5px;">Total Quantity:</label>
                    <input type="number" id="editTotalQuantity" min="1" required style="width: calc(100% - 12px); padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px;">
                </p>
                <p>
                    <label for="editSold" style="display: block; margin-bottom: 5px;">Sold:</label>
                    <input type="number" id="editSold" min="0" required style="width: calc(100% - 12px); padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px;">
                </p>
                <div style="text-align: right;">
                    <button type="submit" style="background-color: var(--primary); color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem; margin-right: 10px;">Save Changes</button>
                    <button type="button" id="cancelEdit" style="background-color: var(--secondary); color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem;">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div id="salesLogModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Sales Log</h2>

            <div class="filter-controls">
<div style="margin: 10px 0;">
    <label for="salesLogPdfRange">Select Range:</label>
    <select id="salesLogPdfRange">
        <option value="all">All Sales</option>
        <option value="last24">Last 24 Hours</option>
    </select>
    <button id="generateSalesLogPdfBtn">Save Sales Log to PDF</button>
</div>

                <label for="salesLogStartDate">From:</label>
                <input type="date" id="salesLogStartDate">
                <label for="salesLogEndDate">To:</label>
                <input type="date" id="salesLogEndDate">
                <button id="applySalesLogFilter">Apply Filter</button>
<button id="last24HoursFilterBtn">Last 24 Hours</button>
                <button id="clearSalesLogFilter">Clear Filter</button>
                <button id="mergeItemsBtn">Item With Total</button>
            </div>

            <table class="inventory-table sales-log-table">
                <thead>
                    <tr>
                        <th>Item Name</th>
                        <th>Brand</th>
                        <th>Quantity Sold</th>
                        <th>Timestamp</th>
                    </tr>
                </thead>
                <tbody id="salesLogTableBody">
                </tbody>
            </table>
        </div>
    </div>


    <footer>
        <p>&copy; Developed by Shane Computers.</p>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
   <script>


// Helper function for displaying modal messages
function showModalMessage(message) {
    const messageBox = document.createElement('div');
    messageBox.className = 'modal-message';
    messageBox.innerHTML = `
        <p>${message}</p>
        <button class="modal-message-close">Close</button>
    `;
    document.body.appendChild(messageBox);
    messageBox.querySelector('.modal-message-close').onclick = () => messageBox.remove();
}

// --- DOM Element References (Ensure these IDs exist in your HTML) ---
const addItemForm = document.getElementById('addItemForm');
const itemTableBody = document.getElementById('itemTableBody');
const totalItemsCount = document.getElementById('totalItemsCount');
const totalQuantityCount = document.getElementById('totalQuantityCount');
const totalSoldCount = document.getElementById('totalSoldCount');
const totalInStockCount = document.getElementById('totalInStockCount');
const totalValueCount = document.getElementById('totalValueCount'); // This will now show Total Revenue (if implemented)
const monthlySoldBarChartCtx = document.getElementById('monthlySoldBarChart')?.getContext('2d'); // Use optional chaining for robustness
const soldItemsPieChartCtx = document.getElementById('soldItemsPieChart')?.getContext('2d'); // Use optional chaining for robustness
const modeToggleBtn = document.getElementById('modeToggleBtn');

// Filter inputs for main inventory table
const filterNameInput = document.getElementById('filterName');
const filterBrandInput = document.getElementById('filterBrand');
const filterStatusSelect = document.getElementById('filterStatus');
const filterStartDateInput = document.getElementById('filterStartDate');
const filterEndDateInput = document.getElementById('filterEndDate');

// Action buttons for export/import/print
const downloadZipBtn = document.getElementById('downloadZipBtn');
const importJsonFile = document.getElementById('importJsonFile');
const importJsonBtn = document.getElementById('importJsonBtn');
const printPdfBtn = document.getElementById('printPdfBtn');

// Edit Item Modal elements
const editItemModal = document.getElementById('editItemModal');
const editItemForm = document.getElementById('editItemForm');
const closeButton = editItemModal?.querySelector('.close-button'); // Use optional chaining
const cancelEditButton = document.getElementById('cancelEdit');

const editItemId = document.getElementById('editItemId');
const editItemName = document.getElementById('editItemName');
const editBrand = document.getElementById('editBrand');
const editTotalQuantity = document.getElementById('editTotalQuantity');
const editSold = document.getElementById('editSold');

// Dashboard element for total sold in last 24 hours (or 1 hour, as configured)
const totalSoldLast24HoursCount = document.getElementById('totalSoldLast24HoursCount');

// --- SALES LOG ELEMENTS ---
const viewSalesLogBtn = document.getElementById('viewSalesLogBtn');
const salesLogModal = document.getElementById('salesLogModal');
const closeSalesLogButton = salesLogModal?.querySelector('.close-button'); // Use optional chaining
const salesLogTableBody = document.getElementById('salesLogTableBody');
const salesLogStartDateInput = document.getElementById('salesLogStartDate');
const salesLogEndDateInput = document.getElementById('salesLogEndDate');
const applySalesLogFilterBtn = document.getElementById('applySalesLogFilter');
const clearSalesLogFilterBtn = document.getElementById('clearSalesLogFilter');

// Sales Log PDF generation elements (New: assuming salesLogPdfRange is a select element)
const salesLogPdfRange = document.getElementById('salesLogPdfRange');
const generateSalesLogPdfBtn = document.getElementById('generateSalesLogPdfBtn');
const last24HoursFilterBtn = document.getElementById('last24HoursFilterBtn'); // For quick filter button

// Button for merging sales log entries
const mergeItemsBtn = document.getElementById('mergeItemsBtn');

// Scroll to top/bottom buttons
const scrollToTopBtn = document.getElementById('scrollToTopBtn');
const scrollToBottomBtn = document.getElementById('scrollToBottomBtn');

// Data storage
let items = JSON.parse(localStorage.getItem('inventoryItems')) || [];

// Global variable to store currently filtered items for PDF generation (main table)
let filteredItemsForDisplay = [];

// Global variable to store currently displayed sales log entries for PDF generation
let filteredSalesLogEntries = [];

// Password for sensitive actions (editing/deleting)
const password = '789632'; // Consider storing this more securely in a real application

// Chart instances
let monthlySoldBarChart = null;
let soldItemsPieChart = null;

// --- Data Persistence ---
function saveItems() {
    localStorage.setItem('inventoryItems', JSON.stringify(items));
}

// --- Sales Log Functionality ---
function displaySalesLog() {
    if (!salesLogTableBody) return; // Exit if sales log table body isn't found

    salesLogTableBody.innerHTML = ''; // Clear previous log entries

    const startDate = salesLogStartDateInput?.value ? new Date(salesLogStartDateInput.value) : null;
    const endDate = salesLogEndDateInput?.value ? new Date(salesLogEndDateInput.value) : null;

    if (startDate) startDate.setHours(0, 0, 0, 0);
    if (endDate) endDate.setHours(23, 59, 59, 999);

    let allSalesEntries = [];

    items.forEach(item => {
        if (item.saleHistory && Array.isArray(item.saleHistory)) {
            item.saleHistory.forEach(sale => {
                const saleTimestamp = new Date(sale.timestamp);
                const matchesDate = (!startDate || saleTimestamp >= startDate) && (!endDate || saleTimestamp <= endDate);

                if (matchesDate) {
                    allSalesEntries.push({
                        itemName: item.name,
                        quantity: sale.quantity,
                        timestamp: saleTimestamp
                    });
                }
            });
        }
    });

    // Sort sales entries by most recent first
    allSalesEntries.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());

    // Store the filtered sales log entries for PDF generation
    filteredSalesLogEntries = allSalesEntries;

    if (allSalesEntries.length === 0) {
        const noDataRow = document.createElement('tr');
        noDataRow.innerHTML = `<td colspan="3" style="text-align: center;">No sales recorded for the selected period.</td>`;
        salesLogTableBody.appendChild(noDataRow);
        return;
    }

    // Re-create table header for detailed view
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    headerRow.innerHTML = `<th>Item Name</th><th>Quantity</th><th>Timestamp</th>`;
    thead.appendChild(headerRow);
    // Clear salesLogTableBody, then append thead, then append rows
    salesLogTableBody.innerHTML = '';
    salesLogTableBody.appendChild(thead);

    allSalesEntries.forEach(entry => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>${entry.itemName}</td>
            <td>${entry.quantity}</td>
            <td>${entry.timestamp.toLocaleString()}</td>
        `;
        salesLogTableBody.appendChild(tr);
    });
}

function displayMergedSalesLog() {
    if (!salesLogTableBody) return;

    salesLogTableBody.innerHTML = ''; // Clear existing content

    const mergedSalesData = {};

    items.forEach(item => {
        if (item.saleHistory && Array.isArray(item.saleHistory)) {
            item.saleHistory.forEach(sale => {
                const saleTimestamp = new Date(sale.timestamp);

                // Apply date filters if any
                const startDate = salesLogStartDateInput?.value ? new Date(salesLogStartDateInput.value) : null;
                const endDate = salesLogEndDateInput?.value ? new Date(salesLogEndDateInput.value) : null;
                if (startDate) startDate.setHours(0, 0, 0, 0);
                if (endDate) endDate.setHours(23, 59, 59, 999);

                const matchesDate = (!startDate || saleTimestamp >= startDate) && (!endDate || saleTimestamp <= endDate);

                if (matchesDate) {
                    mergedSalesData[item.name] = (mergedSalesData[item.name] || 0) + sale.quantity;
                }
            });
        }
    });

    // Convert to an array for sorting and display
    const mergedSalesEntries = Object.entries(mergedSalesData)
        .map(([itemName, totalQuantity]) => ({ itemName, totalQuantity }))
        .sort((a, b) => a.itemName.localeCompare(b.itemName)); // Sort alphabetically by item name

    // Store the merged sales log entries for PDF generation (if needed for a "merged" PDF)
    filteredSalesLogEntries = mergedSalesEntries; // Overwrite if this view is considered the "filtered" one

    if (mergedSalesEntries.length === 0) {
        const noDataRow = document.createElement('tr');
        noDataRow.innerHTML = `<td colspan="2" style="text-align: center;">No sales recorded for the selected period.</td>`;
        salesLogTableBody.appendChild(noDataRow);
        return;
    }

    // Create table header for merged view
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    headerRow.innerHTML = `<th>Item Name</th><th>Total Sold Quantity</th>`;
    thead.appendChild(headerRow);
    salesLogTableBody.appendChild(thead); // Append thead here

    mergedSalesEntries.forEach(entry => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>${entry.itemName}</td>
            <td>${entry.totalQuantity}</td>
        `;
        salesLogTableBody.appendChild(tr);
    });
}


function refreshUI() {
    if (!itemTableBody) return; // Exit if main item table body isn't found

    itemTableBody.innerHTML = ''; // Clear table

    // Get filter values
    const nameFilter = filterNameInput?.value.trim().toLowerCase() || '';
    const brandFilter = filterBrandInput?.value.trim().toLowerCase() || '';
    const statusFilter = filterStatusSelect?.value || 'all';

    // Get date filters for main table (based on dateAdded)
    const startDate = filterStartDateInput?.value ? new Date(filterStartDateInput.value) : null;
    const endDate = filterEndDateInput?.value ? new Date(filterEndDateInput.value) : null;

    // Normalize dates to start/end of day for accurate comparison
    if (startDate) startDate.setHours(0, 0, 0, 0);
    if (endDate) endDate.setHours(23, 59, 59, 999);

    // First, filter by name, brand, and date added range
    let displayItems = items.filter(item => {
        const matchesName = item.name.toLowerCase().includes(nameFilter);
        const matchesBrand = item.brand.toLowerCase().includes(brandFilter);

        // Date range filtering logic based on dateAdded
        const itemDate = new Date(item.dateAdded);
        if (startDate && itemDate < startDate) return false;
        if (endDate && itemDate > endDate) return false;

        return matchesName && matchesBrand;
    });

    // Then, apply status filtering or sorting
    if (statusFilter === 'inStock') {
        displayItems = displayItems.filter(item => (item.totalQuantity - item.sold) > 0);
    } else if (statusFilter === 'soldOut') {
        displayItems = displayItems.filter(item => (item.totalQuantity - item.sold) <= 0);
    } else if (statusFilter === 'lowStock') { // Low Stock filter logic (e.g., 5 or less in stock)
        displayItems = displayItems.filter(item => {
            const inStock = item.totalQuantity - item.sold;
            return inStock > 0 && inStock <= 5; // Must be in stock but low
        });
    } else if (statusFilter === 'highSold') {
        displayItems.sort((a, b) => b.sold - a.sold); // Sort by sold quantity (descending)
    } else if (statusFilter === 'lowSold') {
        displayItems.sort((a, b) => a.sold - b.sold); // Sort by sold quantity (ascending)
    } else if (statusFilter === 'lastEdited') {
        // Sort by lastEdited date (newest first), falling back to dateAdded if lastEdited is missing
        displayItems.sort((a, b) => new Date(b.lastEdited || b.dateAdded).getTime() - new Date(a.lastEdited || a.dateAdded).getTime());
    } else if (statusFilter === 'lastSold') {
        // Sort by lastSoldDate (newest first), items without lastSoldDate will appear last
        displayItems.sort((a, b) => {
            const dateA = a.lastSoldDate ? new Date(a.lastSoldDate).getTime() : 0;
            const dateB = b.lastSoldDate ? new Date(b.lastSoldDate).getTime() : 0;
            return dateB - dateA;
        });
    }

    // Store the filtered items in the global variable for PDF generation
    filteredItemsForDisplay = displayItems;

    // Render items to the table
    displayItems.forEach(item => {
        const tr = document.createElement('tr');
        const inStockCount = item.totalQuantity - item.sold;

        // Add 'critical-low-stock' class if item is 0 or less in stock
        if (inStockCount <= 0) {
            tr.classList.add('critical-low-stock');
        } else if (inStockCount <= 5) { // Add 'low-stock' class if item is between 1 and 5 in stock
            tr.classList.add('low-stock');
        }

        // Calculate Last Sold Quantity within the last 1 hour for dashboard (configurable)
        const oneHourAgo = new Date(Date.now() - 1 * 60 * 60 * 1000);
        let last1HourSold = 0;
        if (item.saleHistory && Array.isArray(item.saleHistory)) {
            const recentSales = item.saleHistory.filter(sale => new Date(sale.timestamp) >= oneHourAgo);
            last1HourSold = recentSales.reduce((sum, sale) => sum + sale.quantity, 0);
        } else {
            item.saleHistory = []; // Ensure saleHistory is an array
        }

        const lastSoldQtyDisplay = last1HourSold > 0 ? last1HourSold : 'N/A';
        const lastEditedDisplay = item.lastEdited ? new Date(item.lastEdited).toLocaleString() : 'N/A';

        tr.innerHTML = `
            <td>${item.name}</td>
            <td>${item.brand}</td>
            <td>${item.totalQuantity}</td>
            <td>
                <button class="sold-dec" aria-label="Decrease sold count for ${item.name}" ${item.sold <= 0 ? 'disabled' : ''}>-</button>
                ${item.sold}
                <button class="sold-inc" aria-label="Increase sold count for ${item.name}" ${inStockCount <= 0 ? 'disabled' : ''}>+</button>
            </td>
            <td>${inStockCount}</td>
            <td>${lastSoldQtyDisplay}</td>
            <td>${lastEditedDisplay}</td>
            <td class="item-actions">
                <button class="edit" aria-label="Edit all details for ${item.name}">All</button>
                <button class="edit-qty" aria-label="Edit total quantity for ${item.name}">Qty</button>
                <button class="edit-sold" aria-label="Edit total quantity for ${item.name}">Sold</button>
                <button class="delete" aria-label="Delete ${item.name}">üóëÔ∏è</button>
                <button class="duplicate" aria-label="Duplicate ${item.name}">üóê</button>
            </td>
        `;

        // --- Event Listeners for Item Actions ---
        tr.querySelector('.sold-dec').onclick = () => {
            if (item.sold > 0) {
                item.sold--;
                item.lastEdited = new Date().toISOString();

                // Logic to remove the *latest* single sale from history
                if (item.saleHistory && item.saleHistory.length > 0) {
                    // Sort descending by timestamp to target the latest sale
                    item.saleHistory.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
                    let removed = false;
                    for (let i = 0; i < item.saleHistory.length; i++) {
                        if (item.saleHistory[i].quantity >= 1) {
                            item.saleHistory[i].quantity--;
                            if (item.saleHistory[i].quantity === 0) {
                                item.saleHistory.splice(i, 1);
                            }
                            removed = true;
                            break;
                        }
                    }
                    // Re-sort ascending if you typically maintain it that way
                    item.saleHistory.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                }

                saveItems();
                refreshUI();
            }
        };

        tr.querySelector('.sold-inc').onclick = () => {
            if (inStockCount > 0) {
                item.sold++;
                item.lastEdited = new Date().toISOString();
                const now = new Date().toISOString();
                if (!item.saleHistory) item.saleHistory = [];
                item.saleHistory.push({ timestamp: now, quantity: 1 });
                item.lastSoldDate = now; // Update lastSoldDate
                saveItems();
                refreshUI();
            }
        };

        tr.querySelector('.edit').onclick = () => {
            const userPass = prompt('Enter password to edit this item:');
            if (userPass === password) {
                const itemIndex = items.findIndex(i => i === item);
                if (itemIndex > -1) {
                    if (editItemId) editItemId.value = itemIndex;
                    if (editItemName) editItemName.value = item.name;
                    if (editBrand) editBrand.value = item.brand;
                    if (editTotalQuantity) editTotalQuantity.value = item.totalQuantity;
                    if (editSold) editSold.value = item.sold;

                    if (editItemModal) editItemModal.style.display = 'flex';
                }
            } else {
                showModalMessage('Wrong password!');
            }
        };

        tr.querySelector('.edit-qty').onclick = () => {
            const userPass = prompt('Enter password to edit quantity:');
            if (userPass === password) {
                const quantityToAdd = parseInt(prompt('Enter quantity to add (use 0 for no change, negative to remove):', 0), 10);
                if (isNaN(quantityToAdd)) {
                    showModalMessage('Invalid quantity. Please enter a number.');
                    return;
                }

                item.totalQuantity += quantityToAdd;
                // Prevent totalQuantity from going below sold quantity
                if (item.totalQuantity < item.sold) {
                    item.totalQuantity = item.sold;
                    showModalMessage('Total quantity cannot be less than sold quantity. Adjusted total quantity to match sold quantity.');
                }
                item.lastEdited = new Date().toISOString();
                saveItems();
                refreshUI();
            } else {
                showModalMessage('Wrong password!');
            }
        };

        tr.querySelector('.edit-sold').onclick = () => {
            const userPass = prompt('Enter password to edit sold quantity:');
            if (userPass === password) {
                const quantityToAdjust = parseInt(prompt('Enter quantity to add to sold (use negative to decrease):', 0), 10);
                if (isNaN(quantityToAdjust)) {
                    showModalMessage('Invalid sold quantity. Please enter a number.');
                    return;
                }

                const newSoldQuantity = (item.sold || 0) + quantityToAdjust;

                if (newSoldQuantity < 0) {
                    showModalMessage('Sold quantity cannot be negative.');
                    return;
                }
                if (newSoldQuantity > item.totalQuantity) {
                    showModalMessage('Sold quantity cannot exceed total quantity.');
                    return;
                }

                // Update saleHistory based on adjustment
                if (quantityToAdjust > 0) {
                    const now = new Date().toISOString();
                    if (!item.saleHistory) item.saleHistory = [];
                    item.saleHistory.push({ timestamp: now, quantity: quantityToAdjust });
                    item.lastSoldDate = now;
                } else if (quantityToAdjust < 0) {
                    const actualDecrease = -quantityToAdjust;
                    if (item.saleHistory && Array.isArray(item.saleHistory)) {
                        let remainingToDecrease = actualDecrease;
                        item.saleHistory.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()); // Newest first

                        const newSaleHistory = [];
                        for (const sale of item.saleHistory) {
                            if (remainingToDecrease > 0) {
                                const reducedFromThisSale = Math.min(sale.quantity, remainingToDecrease);
                                sale.quantity -= reducedFromThisSale;
                                remainingToDecrease -= reducedFromThisSale;
                            }
                            if (sale.quantity > 0) {
                                newSaleHistory.push(sale);
                            }
                        }
                        item.saleHistory = newSaleHistory.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()); // Oldest first
                    }
                }

                item.sold = newSoldQuantity;
                item.lastEdited = new Date().toISOString();
                saveItems();
                refreshUI();
            } else {
                showModalMessage('Wrong password!');
            }
        };

        tr.querySelector('.delete').onclick = () => {
            const userPass = prompt('Enter password to delete this item:');
            if (userPass === password) {
                items = items.filter(i => i !== item);
                saveItems();
                refreshUI();
            } else {
                showModalMessage('Wrong password!');
            }
        };

        tr.querySelector('.duplicate').onclick = () => {
            let newName = item.name;
            let counter = 0;
            // Find a unique name for the duplicate
            while (items.some(i => i.name.toLowerCase() === newName.toLowerCase())) {
                counter++;
                newName = `${item.name} - Copy (${counter})`;
            }
            items.push({
                ...item, // Copy all existing properties
                name: newName,
                dateAdded: new Date().toISOString(), // New date for duplicated item
                sold: 0, // Reset sold count for duplicate
                // totalQuantity: item.totalQuantity, // Keep original quantity (if desired)
                lastEdited: new Date().toISOString(), // Set lastEdited for duplicated item
                saleHistory: [], // Reset sale history for duplicated item
                lastSoldDate: null, // Reset lastSoldDate for duplicate
            });
            saveItems();
            refreshUI();
        };

        itemTableBody.appendChild(tr);
    });

    updateDashboard();
    updateCharts();
}


function updateDashboard() {
    if (!totalItemsCount || !totalQuantityCount || !totalSoldCount || !totalInStockCount || !totalSoldLast24HoursCount) {
        // console.warn("Dashboard elements not found, skipping updateDashboard.");
        return; // Exit if dashboard elements are missing
    }

    const totalItems = items.length;
    const totalQuantity = items.reduce((acc, i) => acc + i.totalQuantity, 0);
    const totalSold = items.reduce((acc, i) => acc + i.sold, 0);
    const totalInStock = totalQuantity - totalSold;

    // Calculate total sold in last 1 hour across all items (as currently configured)
    const oneHourAgo = new Date(Date.now() - 1 * 60 * 60 * 1000);
    let totalSoldLast1Hour = 0;

    items.forEach(item => {
        if (item.saleHistory && Array.isArray(item.saleHistory)) {
            const itemSalesLast1Hour = item.saleHistory.filter(sale => new Date(sale.timestamp) >= oneHourAgo);
            totalSoldLast1Hour += itemSalesLast1Hour.reduce((sum, sale) => sum + sale.quantity, 0);
        }
    });

    totalItemsCount.textContent = totalItems;
    totalQuantityCount.textContent = totalQuantity;
    totalSoldCount.textContent = totalSold;
    totalInStockCount.textContent = totalInStock;
    totalSoldLast24HoursCount.textContent = totalSoldLast1Hour; // This element shows 1-hour sales
}

function updateCharts() {
    // Only proceed if chart contexts are available
    if (!monthlySoldBarChartCtx || !soldItemsPieChartCtx) {
        // console.warn("Chart canvases not found, skipping chart update.");
        return;
    }

    // Monthly Sold Bar Chart
    const monthlyData = {};

    items.forEach(item => {
        if (item.saleHistory && Array.isArray(item.saleHistory)) {
            item.saleHistory.forEach(sale => {
                const d = new Date(sale.timestamp);
                if (isNaN(d.getTime())) return; // Check for valid date
                const key = `${d.getFullYear()}-${('0' + (d.getMonth() + 1)).slice(-2)}`;
                if (!monthlyData[key]) monthlyData[key] = 0;
                monthlyData[key] += sale.quantity;
            });
        }
    });

    const months = Object.keys(monthlyData).sort();

    const monthLabels = months.map(m => {
        const [year, month] = m.split('-');
        const date = new Date(parseInt(year), parseInt(month) - 1);
        return date.toLocaleString('default', { month: 'short', year: 'numeric' });
    });

    const soldCounts = months.map(m => monthlyData[m]);

    if (monthlySoldBarChart) monthlySoldBarChart.destroy(); // Destroy previous instance

    monthlySoldBarChart = new Chart(monthlySoldBarChartCtx, {
        type: 'bar',
        data: {
            labels: monthLabels,
            datasets: [{
                label: 'Items Sold',
                data: soldCounts,
                backgroundColor: 'rgba(0, 123, 255, 0.7)',
                borderColor: 'rgba(0, 123, 255, 1)',
                borderWidth: 1,
                borderRadius: 4,
            }]
        },
        options: {
            responsive: true,
            scales: {
                y: { beginAtZero: true, stepSize: 1 },
            },
            plugins: {
                legend: { display: false },
                tooltip: { enabled: true }
            }
        }
    });

    // Pie Chart: Top 20 Most Sold Items in the Last 7 Days
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    sevenDaysAgo.setHours(0, 0, 0, 0);

    const weeklySoldItemsData = {};

    items.forEach(item => {
        if (item.saleHistory && Array.isArray(item.saleHistory)) {
            item.saleHistory.forEach(sale => {
                const saleDate = new Date(sale.timestamp);
                if (saleDate >= sevenDaysAgo) {
                    weeklySoldItemsData[item.name] = (weeklySoldItemsData[item.name] || 0) + sale.quantity;
                }
            });
        }
    });

    const sortedWeeklySoldItems = Object.entries(weeklySoldItemsData)
        .sort(([, soldA], [, soldB]) => soldB - soldA);

    const top20WeeklySoldItems = sortedWeeklySoldItems.slice(0, 20);

    const pieLabels = top20WeeklySoldItems.map(entry => entry[0]);
    const pieValues = top20WeeklySoldItems.map(entry => entry[1]);
    const pieColors = pieLabels.map(() => `hsl(${Math.random() * 360}, 70%, 60%)`);

    if (soldItemsPieChart) soldItemsPieChart.destroy(); // Destroy previous instance

    soldItemsPieChart = new Chart(soldItemsPieChartCtx, {
        type: 'pie',
        data: {
            labels: pieLabels,
            datasets: [{
                data: pieValues,
                backgroundColor: pieColors,
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { position: 'bottom' },
                tooltip: { enabled: true }
            }
        }
    });
}

// --- Event Listeners and Initializations ---

// Add Item Form Submission
if (addItemForm) {
    addItemForm.onsubmit = (e) => {
        e.preventDefault();

        const nameInput = document.getElementById('itemName');
        const brandInput = document.getElementById('brand');
        const totalQuantityInput = document.getElementById('totalQuantity');
        const soldInput = document.getElementById('sold');

        if (!nameInput || !brandInput || !totalQuantityInput || !soldInput) {
            showModalMessage('Missing form input elements.');
            return;
        }

        const name = nameInput.value.trim();
        const brand = brandInput.value.trim();
        const totalQuantity = parseInt(totalQuantityInput.value, 10);
        const sold = parseInt(soldInput.value, 10);

        if (!name || !brand || isNaN(totalQuantity) || isNaN(sold)) {
            showModalMessage('Please fill all fields correctly.');
            return;
        }
        if (sold > totalQuantity) {
            showModalMessage('Sold quantity cannot be greater than total quantity.');
            return;
        }

        // Check if item name already exists (case-insensitive)
        if (items.some(i => i.name.toLowerCase() === name.toLowerCase())) {
            showModalMessage('An item with this name already exists. Please use a different name or duplicate it later.');
            return;
        }

        const now = new Date().toISOString();
        const newItem = {
            name,
            brand,
            totalQuantity,
            sold,
            dateAdded: now,
            lastEdited: now,
            saleHistory: sold > 0 ? [{ timestamp: now, quantity: sold }] : [],
            lastSoldDate: sold > 0 ? now : null,
        };

        items.push(newItem);
        saveItems();
        refreshUI();

        addItemForm.reset();
    };
}

// Import JSON Event Listeners
if (importJsonBtn && importJsonFile) {
    importJsonBtn.addEventListener('click', () => {
        importJsonFile.click(); // Trigger the hidden file input
    });

    importJsonFile.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (!Array.isArray(importedData)) {
                        showModalMessage('Invalid JSON file. Expected an array of items.');
                        return;
                    }

                    const processedData = importedData.map(item => {
                        const now = new Date().toISOString();
                        return {
                            id: item.id || Date.now() + Math.random(), // Add random for better uniqueness
                            name: item.name || 'Untitled Item',
                            brand: item.brand || 'No Brand',
                            totalQuantity: typeof item.totalQuantity === 'number' ? item.totalQuantity : 0,
                            sold: typeof item.sold === 'number' ? item.sold : 0,
                            dateAdded: item.dateAdded || now,
                            lastEdited: item.lastEdited || now,
                            saleHistory: Array.isArray(item.saleHistory) ? item.saleHistory : [],
                            lastSoldDate: item.lastSoldDate || (item.sold > 0 ? now : null)
                        };
                    });

                    items = processedData;
                    showModalMessage('Inventory imported successfully! Refreshing data...');

                    saveItems();
                    refreshUI();
                    displaySalesLog(); // Also refresh sales log if it's open
                } catch (error) {
                    showModalMessage(`Error reading JSON file: ${error.message}`);
                    console.error('Error parsing JSON:', error);
                }
            };
            reader.readAsText(file);
        }
    });
}

// Download ZIP Event Listener
if (downloadZipBtn) {
    downloadZipBtn.addEventListener('click', async () => {
        showModalMessage('Preparing files for download...');

        try {
            const inventoryData = JSON.stringify(items, null, 2);

            // Ensure JSZip is loaded.
            if (typeof JSZip === 'undefined') {
                showModalMessage('JSZip library not found. Please ensure it\'s loaded.');
                return;
            }

            const zip = new JSZip();
            zip.file("inventory_data.json", inventoryData);

            const content = await zip.generateAsync({ type: "blob" });

            const a = document.createElement('a');
            a.href = URL.createObjectURL(content);
            a.download = `inventory_backup_${new Date().toISOString().slice(0, 10)}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            showModalMessage('Inventory data downloaded as ZIP!');
        } catch (error) {
            console.error('Error zipping files:', error);
            showModalMessage(`Failed to generate ZIP: ${error.message || 'An unknown error occurred.'}`);
        }
    });
}

// Print PDF Event Listener for Main Inventory Table (Using html2pdf)
if (printPdfBtn) {
    printPdfBtn.onclick = async () => {
        showModalMessage('Attempting to generate Inventory PDF... Please wait.');

        const pdfContent = document.createElement('div');
        const reportTitle = document.createElement('h1');
        reportTitle.textContent = `Inventory In-Stock Report - ${new Date().toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: 'numeric' })}`;
        reportTitle.style.textAlign = 'center';
        reportTitle.style.marginBottom = '20px';
        reportTitle.style.marginTop = '0';
        pdfContent.appendChild(reportTitle);

        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.borderCollapse = 'collapse';
        table.style.marginTop = '0';
        table.style.fontFamily = 'Arial, sans-serif'; // Added for better PDF rendering

        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');

        const headers = ['Item Name', 'In Stock Quantity', 'Total Sold', 'Date Added'];
        headers.forEach(headerText => {
            const th = document.createElement('th');
            th.textContent = headerText;
            th.style.backgroundColor = '#007bff';
            th.style.color = 'white';
            th.style.padding = '10px';
            th.style.border = '1px solid #dee2e6';
            th.style.textAlign = 'left';
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        if (filteredItemsForDisplay.length === 0) {
            const noDataRow = document.createElement('tr');
            noDataRow.innerHTML = `<td colspan="4" style="text-align: center; padding: 10px;">No items to display for the current filter.</td>`;
            tbody.appendChild(noDataRow);
        } else {
            filteredItemsForDisplay.forEach(item => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td style="padding: 10px; border: 1px solid #dee2e6;">${item.name}</td>
                    <td style="padding: 10px; border: 1px solid #dee2e6;">${item.totalQuantity - item.sold}</td>
                    <td style="padding: 10px; border: 1px solid #dee2e6;">${item.sold}</td>
                    <td style="padding: 10px; border: 1px solid #dee2e6;">${new Date(item.dateAdded).toLocaleDateString()}</td>
                `;
                tbody.appendChild(tr);
            });
        }
        table.appendChild(tbody);
        pdfContent.appendChild(table);

        document.body.appendChild(pdfContent); // Temporarily append to DOM for html2pdf

        const options = {
            margin: 10,
            filename: `inventory_in_stock_report_${new Date().toISOString().slice(0, 10)}.pdf`,
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: {
                scale: 2,
                logging: true,
                useCORS: true
            },
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
        };

        try {
            // Ensure html2pdf is loaded. You must include it via <script> tag.
            if (typeof html2pdf === 'undefined') {
                showModalMessage('html2pdf.js library not found. Please ensure it\'s loaded.');
                return;
            }
            await html2pdf().set(options).from(pdfContent).save();
            showModalMessage('Inventory PDF generated and downloaded successfully!');
        } catch (error) {
            console.error('Inventory PDF Generation Error:', error);
            showModalMessage(`Failed to generate Inventory PDF: ${error.message || 'An unknown error occurred.'}. Check console for details.`);
        } finally {
            if (pdfContent && pdfContent.parentNode) {
                pdfContent.parentNode.removeChild(pdfContent);
            }
        }
    };
}


if (generateSalesLogPdfBtn) {
    generateSalesLogPdfBtn.onclick = async () => {
        showModalMessage('Attempting to generate Sales Log PDF... Please wait.');

        // This line assumes a select element with id 'salesLogPdfRange' is present.
        // If not, you might want to default to 'all' or remove this if not needed.
        const range = salesLogPdfRange?.value || 'all';
        const now = new Date();
        const last24 = new Date(now.getTime() - 24 * 60 * 60 * 1000);

        const pdfContent = document.createElement('div');
        const title = document.createElement('h2');
        title.textContent = `Sales Log Report (${range === 'last24' ? 'Last 24 Hours' : 'All Sales'}) - ${now.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: 'numeric' })}`;
        title.style.textAlign = 'center';
        title.style.margin = '20px 0';
        pdfContent.appendChild(title);

        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.borderCollapse = 'collapse';
        table.style.fontFamily = 'Arial, sans-serif'; // Added for better PDF rendering

        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        // Headers for the sales log: Item Name, Quantity Sold, Timestamp
        ['Item Name', 'Quantity Sold', 'Timestamp'].forEach(text => {
            const th = document.createElement('th');
            th.textContent = text;
            th.style.border = '1px solid #ccc';
            th.style.padding = '8px';
            th.style.background = '#007bff';
            th.style.color = '#fff';
            headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        let salesToExport = []; // Will hold the sales entries for the PDF

        if (range === 'last24') {
            items.forEach(item => {
                if (item.saleHistory && Array.isArray(item.saleHistory)) {
                    item.saleHistory.forEach(sale => {
                        const saleTimestamp = new Date(sale.timestamp);
                        if (saleTimestamp >= last24 && saleTimestamp <= now) {
                            salesToExport.push({
                                itemName: item.name,
                                quantity: sale.quantity,
                                timestamp: saleTimestamp
                            });
                        }
                    });
                }
            });
            salesToExport.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime()); // Sort newest first
        } else { // 'all'
            // Collect all sales history entries from all items
            items.forEach(item => {
                if (item.saleHistory && Array.isArray(item.saleHistory)) {
                    item.saleHistory.forEach(sale => {
                        salesToExport.push({
                            itemName: item.name,
                            quantity: sale.quantity,
                            timestamp: new Date(sale.timestamp)
                        });
                    });
                }
            });
            salesToExport.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime()); // Sort newest first
        }

        if (salesToExport.length === 0) {
            const noDataRow = document.createElement('tr');
            noDataRow.innerHTML = `<td colspan="3" style="text-align: center; padding: 8px;">No sales recorded for this period.</td>`;
            tbody.appendChild(noDataRow);
        } else {
            salesToExport.forEach((entry, index) => {
                const tr = document.createElement('tr');
                if (index % 2 === 0) { // Stripe rows
                    tr.style.backgroundColor = '#f2f2f2';
                }
                const tdName = document.createElement('td');
                tdName.textContent = entry.itemName;
                tdName.style.border = '1px solid #ccc';
                tdName.style.padding = '8px';
                tr.appendChild(tdName);

                const tdQuantity = document.createElement('td');
                tdQuantity.textContent = entry.quantity;
                tdQuantity.style.border = '1px solid #ccc';
                tdQuantity.style.padding = '8px';
                tr.appendChild(tdQuantity);

                const tdTimestamp = document.createElement('td');
                tdTimestamp.textContent = entry.timestamp.toLocaleString();
                tdTimestamp.style.border = '1px solid #ccc';
                tdTimestamp.style.padding = '8px';
                tr.appendChild(tdTimestamp);

                tbody.appendChild(tr);
            });
        }

        table.appendChild(tbody);
        pdfContent.appendChild(table);
        document.body.appendChild(pdfContent); // Temporarily append to DOM for html2pdf

        try {
            // Ensure html2pdf is loaded. You must include it via <script> tag.
            if (typeof html2pdf === 'undefined') {
                showModalMessage('html2pdf.js library not found. Please ensure it\'s loaded.');
                return;
            }
            await html2pdf().set({
                filename: `sales_log_${range}_${new Date().toISOString().slice(0, 10)}.pdf`,
                margin: 10,
                html2canvas: { scale: 2 },
                jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
            }).from(pdfContent).save();

            showModalMessage('Sales Log PDF generated and downloaded successfully!');
        } catch (error) {
            console.error('Sales Log PDF Generation Error:', error);
            showModalMessage(`Failed to generate Sales Log PDF: ${error.message || 'An unknown error occurred.'}. Check console for details.`);
        } finally {
            if (pdfContent && pdfContent.parentNode) {
                document.body.removeChild(pdfContent);
            }
        }
    };
}


if (scrollToTopBtn) {
    scrollToTopBtn.addEventListener('click', () => {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    });
}

if (scrollToBottomBtn) {
    scrollToBottomBtn.addEventListener('click', () => {
        window.scrollTo({
            top: document.body.scrollHeight,
            behavior: 'smooth'
        });
    });
}


function loadDarkModeSetting() {
    if (localStorage.getItem('mode') === 'dark') {
        document.body.classList.add('dark-mode');
    }
}

if (modeToggleBtn) {
    modeToggleBtn.addEventListener('click', () => {
        document.body.classList.toggle('dark-mode');
        if (document.body.classList.contains('dark-mode')) {
            localStorage.setItem('mode', 'dark');
        } else {
            localStorage.setItem('mode', 'light');
        }
    });
}


document.addEventListener('DOMContentLoaded', () => {
    loadDarkModeSetting();
    refreshUI(); // Initial refresh of the main inventory table

    // Attach event listeners for main inventory filter inputs
    const applyMainFilters = () => refreshUI();
    filterNameInput?.addEventListener('input', applyMainFilters);
    filterBrandInput?.addEventListener('input', applyMainFilters);
    filterStatusSelect?.addEventListener('change', applyMainFilters);
    filterStartDateInput?.addEventListener('change', applyMainFilters);
    filterEndDateInput?.addEventListener('change', applyMainFilters);


    // Event listeners for Sales Log modal
    if (viewSalesLogBtn) {
        viewSalesLogBtn.onclick = () => {
            if (salesLogModal) salesLogModal.style.display = 'flex';
            if (salesLogStartDateInput) salesLogStartDateInput.value = '';
            if (salesLogEndDateInput) salesLogEndDateInput.value = '';
            displaySalesLog(); // Show all logs initially
        };
    }

    if (closeSalesLogButton) {
        closeSalesLogButton.onclick = () => {
            if (salesLogModal) salesLogModal.style.display = 'none';
        };
    }

    if (applySalesLogFilterBtn) {
        applySalesLogFilterBtn.onclick = displaySalesLog;
    }

    if (clearSalesLogFilterBtn) {
        clearSalesLogFilterBtn.onclick = () => {
            if (salesLogStartDateInput) salesLogStartDateInput.value = '';
            if (salesLogEndDateInput) salesLogEndDateInput.value = '';
            displaySalesLog(); // Show all logs again
        };
    }

    // New button for merging sales log entries
    if (mergeItemsBtn) {
        mergeItemsBtn.addEventListener('click', displayMergedSalesLog);
    }

    // Last 24 Hours quick filter for sales log
    if (last24HoursFilterBtn) {
        last24HoursFilterBtn.onclick = () => {
            const now = new Date();
            const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));

            // Format dates for input fields (YYYY-MM-DD)
            if (salesLogStartDateInput) salesLogStartDateInput.value = twentyFourHoursAgo.toISOString().slice(0, 10);
            if (salesLogEndDateInput) salesLogEndDateInput.value = now.toISOString().slice(0, 10);
            displaySalesLog();
        };
    }

    // Handle edit form submission (inside the modal)
    if (editItemForm) {
        editItemForm.onsubmit = (e) => {
            e.preventDefault();
            const userPass = prompt('Enter password to save changes:');
            if (userPass === password) {
                const itemId = parseInt(editItemId.value, 10);
                if (itemId > -1 && itemId < items.length) {
                    const itemToUpdate = items[itemId];
                    const newName = editItemName.value.trim();
                    const newBrand = editBrand.value.trim();
                    const newTotalQuantity = parseInt(editTotalQuantity.value, 10);
                    const newSold = parseInt(editSold.value, 10);

                    if (!newName || !newBrand || isNaN(newTotalQuantity) || isNaN(newSold)) {
                        showModalMessage('Please fill all fields correctly.');
                        return;
                    }

                    if (newSold > newTotalQuantity) {
                        showModalMessage('Sold quantity cannot be greater than total quantity.');
                        return;
                    }

                    // Check for duplicate name if the name is changed
                    if (newName.toLowerCase() !== itemToUpdate.name.toLowerCase() && items.some((i, idx) => i.name.toLowerCase() === newName.toLowerCase() && idx !== itemId)) {
                        showModalMessage('An item with this name already exists. Please choose a different name.');
                        return;
                    }

                    // If sold quantity increased, record in saleHistory
                    if (newSold > itemToUpdate.sold) {
                        const quantityIncreased = newSold - itemToUpdate.sold;
                        const now = new Date().toISOString();
                        if (!itemToUpdate.saleHistory) itemToUpdate.saleHistory = [];
                        itemToUpdate.saleHistory.push({ timestamp: now, quantity: quantityIncreased });
                        itemToUpdate.lastSoldDate = now;
                    } else if (newSold < itemToUpdate.sold) {
                        const quantityDecreased = itemToUpdate.sold - newSold;
                        if (itemToUpdate.saleHistory && Array.isArray(itemToUpdate.saleHistory)) {
                            let remainingToDecrease = quantityDecreased;
                            itemToUpdate.saleHistory.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()); // Newest first

                            const newSaleHistory = [];
                            for (const sale of itemToUpdate.saleHistory) {
                                if (remainingToDecrease > 0) {
                                    const reducedFromThisSale = Math.min(sale.quantity, remainingToDecrease);
                                    sale.quantity -= reducedFromThisSale;
                                    remainingToDecrease -= reducedFromThisSale;
                                }
                                if (sale.quantity > 0) {
                                    newSaleHistory.push(sale);
                                }
                            }
                            itemToUpdate.saleHistory = newSaleHistory.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()); // Oldest first
                        }
                    }

                    itemToUpdate.name = newName;
                    itemToUpdate.brand = newBrand;
                    itemToUpdate.totalQuantity = newTotalQuantity;
                    itemToUpdate.sold = newSold;
                    itemToUpdate.lastEdited = new Date().toISOString();

                    saveItems();
                    refreshUI();
                    if (editItemModal) editItemModal.style.display = 'none';
                }
            } else {
                showModalMessage('Wrong password!');
            }
        };
    }

    if (closeButton) {
        closeButton.onclick = () => {
            if (editItemModal) editItemModal.style.display = 'none';
        };
    }

    if (cancelEditButton) {
        cancelEditButton.onclick = () => {
            if (editItemModal) editItemModal.style.display = 'none';
        };
    }

    // Set up hourly refresh for the dashboard stats
    setInterval(updateDashboard, 60 * 60 * 1000); // Refresh every 1 hour
});


</script>

</body>
</html>
